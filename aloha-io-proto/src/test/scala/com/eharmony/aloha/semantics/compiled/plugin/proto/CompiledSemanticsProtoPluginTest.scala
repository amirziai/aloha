package com.eharmony.aloha.semantics.compiled.plugin.proto

import com.eharmony.aloha.FileLocations
import com.eharmony.aloha.audit.impl.OptionAuditor
import com.eharmony.aloha.factory.ModelFactory
import com.eharmony.aloha.semantics.compiled.CompiledSemantics
import com.eharmony.aloha.semantics.compiled.compiler.TwitterEvalCompiler
import com.eharmony.aloha.test.proto.TestProtoBuffs.TestProto
import com.eharmony.aloha.test.proto.TestProtoBuffs.TestProto._
import org.junit.Assert._
import org.junit.Test
import org.junit.runner.RunWith
import org.junit.runners.BlockJUnit4ClassRunner

import scala.collection.JavaConversions.asScalaBuffer

@RunWith(classOf[BlockJUnit4ClassRunner])
class CompiledSemanticsProtoPluginTest {
    import CompiledSemanticsProtoPluginTest.{levels, numRepeats, protos, strVal}

    val plugin = CompiledSemanticsProtoPlugin[TestProto]
    val semantics: CompiledSemantics[TestProto] = {
        import concurrent.ExecutionContext.Implicits.global
        // Provide a cache for the classes generated by the compiler.
        CompiledSemantics(TwitterEvalCompiler(classCacheDir = Option(FileLocations.testGeneratedClasses)), plugin, Seq("com.eharmony.aloha.feature.BasicFunctions._"))
    }

    @Test def testRequiredChains() {
        for {
            i <- 1 to levels
            s = "${" + (1 until i).map("req_c" + _ + ".").mkString("") + "req_int_" + i + "}"
            ff = semantics.createFunction[Int](s)
            f = ff.right.toOption.get
            j = i - 1
        } assertEquals("testRequiredChains, case " + j, 10 * j + 1, f(protos(j)))
    }

    // TODO: fix so that type is Seq[Int] instead of Seq[Integer]
    @Test def testRequiredChainsWithRepeated() {
        for {
            i <- 1 to levels
            s = "${" + (1 until i).map("req_c" + _ + ".").mkString + "rep_int_" + i + "}"
            f = semantics.createFunction[Seq[Integer]](s).right.toOption.get
        } assertEquals("testRequiredChainsWithRepeated, case " + i, Seq.range(0, numRepeats).map(_ + 10 * (i - 1) + 2), f(protos(i)))
    }


    @Test def test_O() {
        val missing = Int.MinValue
        val s = "${opt_int_1}"
        val f = semantics.createFunction[Int](s, Option(missing)).right.toOption.get
        assertEquals(0, f(protos.last))
        assertEquals(missing, f(protos.head))
    }

    @Test def testStringEscaping() {
        val s = "${req_str_1} == \"" + strVal + "\""
        val f = semantics.createFunction[Boolean](s).right.toOption.get
        val v = f(protos.head)
        assertTrue("in testStringEscaping...", v)
    }

    /** Construct a ''Map[Int, Float](0 -> 0, 10 -> 0.1, ..., 50 -> 0.5)'',  Then use the value extracted from the
      * proto as a lookup into the map.
      */
    @Test def test_map() {
        // The else here makes the final generated function a non-Optional function.  Whether that non-optional is
        // optionally applied is up to the existence of ${opt_c1.opt_c2.opt_c3.opt_int_4}.  This is why we supply a
        // default to the createFunction function.
        val s = "0.to(50, 10).map(i => (i, i / 100f)).toMap.getOrElse(${opt_c1.opt_c2.opt_c3.opt_int_4}, Float.NegativeInfinity)"

        // Only here for readability.  Want to show that applying f gives 1/100 of this value.
        val c4 = 30
        assertEquals(c4, protos.last.getOptC1.getOptC2.getOptC3.getOptInt4)

        val f = semantics.createFunction[Float](s, Option(Float.NaN)).right.toOption.get
        assertEquals(c4 / 100f, f(protos.last), 1.0e-5)
    }

    /**
      * '''NOTE''': The output type of the function is Seq[Integer] (java.lang.Integer) (not scala.Int).  This is
     * because there is no casting of the value type, just implicit wrapping of container class.
      */
    // TODO fix this in CompiledSemanticsProtoPlugin to do appropriate casting so that Seq[java.lang.X] become Seq[scala.X].
    @Test def test_L() {
        val s = "${rep_int_1}"
        val f = semantics.createFunction[Seq[Integer]](s).right.toOption.get
        assertEquals(Seq(2, 3), f(protos.last))
    }

    /** An optional list of an optional field should map to a list of options.
      */
    @Test def test_OLO() {
        val testCase = protos(4)
        val exp = testCase.getOptC1.getRepC2List.map(c2 => Option(c2.getOptInt3))

        // Because opt_int_3 is an 'optional int32' in the proto definition, and rep_c2 is repeated
        // the resulting type is a sequence of Option of Int.
        val s = "${opt_c1.rep_c2.opt_int_3}"
        val f = semantics.createFunction[Seq[Option[Int]]](s).right.toOption.get

        val act = f(testCase)
        assertEquals(exp, act)
    }

    @Test def test_OROLOOR() {
        val s = "${opt_c1.req_c2.opt_c3.rep_c4.opt_c5.opt_c6.req_int_7}"
        val f = semantics.createFunction[Seq[Option[Int]]](s).right.toOption.get
        assertEquals(Seq.fill(2)(Some(61)), f(protos.last))
    }

    @Test def test_OROLOOO() {
        val s = "${opt_c1.req_c2.opt_c3.rep_c4.opt_c5.opt_c6.opt_int_7}"
        val f = semantics.createFunction[Seq[Option[Int]]](s).right.toOption.get
        assertEquals(Seq.fill(2)(Some(60)), f(protos.last))
    }

    @Test def test_OROL() {
        val s = "${opt_c1.req_c2.opt_c3.rep_c4}"
        val ff = semantics.createFunction[Seq[Class4Proto]](s)
        ff.left.foreach("test_OROL: " + _)
        val f = ff.right.toOption.get
        assertEquals(protos.last.getOptC1.getReqC2.getOptC3.getRepC4List.toSeq, f(protos.last))
    }

    def bagOfWordsProto = protos.last.toBuilder.setReqStr1("handsome smart stubborn").build

    @Test def test_BagOfWords1() {
        val s = """${req_str_1}.split("\\W+").zip(Stream continually 1.0)"""
        val f = semantics.createFunction[Iterable[(String, Double)]](s).right.toOption.get

        val p = protos.last.toBuilder.setReqStr1("handsome smart stubborn").build()
        val a = f(p).toSet
        assertEquals(Set(("handsome", 1.0), ("smart", 1.0), ("stubborn", 1.0)), a)
    }

    @Test def test_BagOfWords2() {
        val f = ModelFactory.defaultFactory(semantics, OptionAuditor[Double]())

        val m = f.fromString(
            """
              |{
              |  "modelType": "Regression",
              |  "modelId": { "id": 0, "name": "" },
              |  "features" : {
              |    "my_attributes": "${req_str_1}.split(\"\\\\W+\").map(v => (s\"=$v\", 1.0))"
              |  },
              |  "weights": {
              |    "my_attributes=handsome": 1,
              |    "my_attributes=smart": 2,
              |    "my_attributes=stubborn": 4
              |  }
              |}
            """.stripMargin).get

        val p = bagOfWordsProto
        val v = m(p).toSeq
        assertEquals(Seq(7), v)
    }


    def time[A](f: => A) = {
        val t1 = System.nanoTime
        val r = f
        val t2 = System.nanoTime
        (r, (1.0e-9*(t2-t1)).toFloat)
    }
}

object CompiledSemanticsProtoPluginTest {
    lazy val protos = (0 to levels).map(testProto(_))

    val numRepeats = 2
    val levels = 7
    val strVal = "test"
    def repeatedSeq(level: Int) = (0 until numRepeats).map(2 + level * 10 + _)
    def optVal(level: Int) = Option(10 * level)

    /** Get a TestProto filled in for user in tests.
      * @param m 0 <= m <= levels.  The number of levels to fill in.
      * @return
      */
    def testProto(m: Int): TestProto = {
        require(0 <= m && m <= levels, "Expected 0 <= m <= " + levels + ". Found " + m)
        val o = (0 until m).map(optVal(_)) ++ Seq.fill(levels - m)(None)
        val s = (0 until m).map(repeatedSeq(_)) ++ Seq.fill(levels - m)(Nil)
        val b0 = c0(o(0),  1, s(0):_*).setReqStr1(strVal)
        val b1 = c1(o(1), 11, s(1):_*)
        val b2 = c2(o(2), 21, s(2):_*)
        val b3 = c3(o(3), 31, s(3):_*)
        val b4 = c4(o(4), 41, s(4):_*)
        val b5 = c5(o(5), 51, s(5):_*)
        val b6 = c6(o(6), 61, s(6):_*)

        if (6 < m) { b5 setOptC6 b6; s(5).foreach(_ => b5 addRepC6 b6)}
        b5 setReqC6 b6
        if (5 < m) { b4 setOptC5 b5; s(4).foreach(_ => b4 addRepC5 b5)}
        b4 setReqC5 b5
        if (4 < m) { b3 setOptC4 b4; s(3).foreach(_ => b3 addRepC4 b4)}
        b3 setReqC4 b4
        if (3 < m) { b2 setOptC3 b3; s(2).foreach(_ => b2 addRepC3 b3)}
        b2 setReqC3 b3
        if (2 < m) { b1 setOptC2 b2; s(1).foreach(_ => b1 addRepC2 b2)}
        b1 setReqC2 b2
        if (1 < m) { b0 setOptC1 b1; s(0).foreach(_ => b0 addRepC1 b1)}
        b0 setReqC1 b1

        val b = b0.build
        b
    }

    def c0(o: Option[Int], r: Int, l: Int*) = {
        val b = TestProto.newBuilder
        o foreach {b setOptInt1 _}
        b setReqInt1 r
        l foreach {b addRepInt1 _}
        b
    }

    def c1(o: Option[Int], r: Int, l: Int*) = {
        val b = Class1Proto.newBuilder
        o foreach {b setOptInt2 _}
        b setReqInt2 r
        l foreach {b addRepInt2 _}
        b
    }

    def c2(o: Option[Int], r: Int, l: Int*) = {
        val b = Class2Proto.newBuilder
        o foreach {b setOptInt3 _}
        b setReqInt3 r
        l foreach {b addRepInt3 _}
        b
    }

    def c3(o: Option[Int], r: Int, l: Int*) = {
        val b = Class3Proto.newBuilder
        o foreach {b setOptInt4 _}
        b setReqInt4 r
        l foreach {b addRepInt4 _}
        b
    }

    def c4(o: Option[Int], r: Int, l: Int*) = {
        val b = Class4Proto.newBuilder
        o foreach {b setOptInt5 _}
        b setReqInt5 r
        l foreach {b addRepInt5 _}
        b
    }

    def c5(o: Option[Int], r: Int, l: Int*) = {
        val b = Class5Proto.newBuilder
        o foreach {b setOptInt6 _}
        b setReqInt6 r
        l foreach {b addRepInt6 _}
        b
    }

    def c6(o: Option[Int], r: Int, l: Int*) = {
        val b = Class6Proto.newBuilder
        o foreach {b setOptInt7 _}
        b setReqInt7 r
        l foreach {b addRepInt7 _}
        b
    }
}
